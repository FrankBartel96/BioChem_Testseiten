<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8 ">
    <!--  <meta name="viewport" content="width=device-width, initial-scale=1.0">  -->
    <!-- /*Zoom*/-->
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=3.0, user-scalable=yes">
    <title>Lotka-Volterra Modell</title>
    <style>
        :root {
            --background: #F6F8E2;
            --card-bg: #f1dbc1;
            --border: #d1d1d6;
            --text: #1c1c1e;
            --green: #34c759;
            --red: #ff3b30;
            --shadow: 0 4px 10px rgba(0, 0, 0, 0.06);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--background);
            margin: 0;
            padding: 40px;
            color: var(--text);
        }

        h1 {
            text-align: center;
            font-size: 1.8em;
            margin-bottom: 20px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 20px;
            box-shadow: var(--shadow);
            padding: 30px;
            max-width: 900px;
            margin: 0 auto 40px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
        }

        input[type="number"], input[type="range"] {
            width: 100px;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 12px;
            font-size: 1em;
            margin-top: 4px;
            background-color: #F6F8E2;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            /*background: var(--text);   */
            width: 100px; /* Breite des Buttons */
            height: 40px; /* Höhe des Buttons */

            background-color: #0071e3;
            color: white;
            border: none;
            border-radius: 12px;
            padding: 10px 16px;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.2s ease;
        }

            button:hover {
                /*  background: #333; */
                background-color: #005bb5;
            }

        canvas {
            background: #fff;
            border-radius: 16px;
            box-shadow: var(--shadow);
            width: 100%;
            max-width: 100%;
            margin-top: 20px;
        }

        .slider-group {
            flex: 1;
            min-width: 200px;
        }

        .label-inline {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .info {
            border-radius: 20px;
            box-shadow: var(--shadow);
            padding: 20px;
            max-width: 900px;
            margin: 0 auto 40px;
        }
        /* Eine minimale und maximale Breite festlegen */
        textarea[readonly] {
            min-width: 200px;
            max-width: 600px;
        }


    </style>
</head>
<body>

    <div class="card">
        <h1>Lotka-Volterra Populationsmodell</h1>
        Startwerte:
        <label>
            Beutepopulation:
            <input type="number" id="preyInput" value="40" min="1">

            Räuberpopulation:
            <input type="number" id="predatorInput" value="8" min="1">

            Mindestpopulation Beute:
            <input type="number" id="minPreyInput" value="4" min="1" step="0.01">
        </label>

        <label>
            α (Beutewachstum):
            <input type="number" id="alphaInput" value="0.1" step="0.01">

            β (Räuber-Effekt auf Beute):
            <input type="number" id="betaInput" value="0.02" step="0.001">
        </label>
        <label>
            δ (Beute-Effekt auf Räuber):
            <input type="number" id="deltaInput" value="0.01" step="0.001">

            γ (Räubersterberate):
            <input type="number" id="gammaInput" value="0.1" step="0.01">
        </label>


        <div class="controls">
            <button onclick="toggleSimulation()" id="toggleBtn">Start</button>
            <button onclick="resetSimulation()">Reset</button>
            <button onclick="location.reload()">Reload</button>
            <button onclick="openQRCode()">QR-Code</button>
            <div class="slider-group">
                <label for="speedSlider">Geschwindigkeit:</label>
                <input type="range" id="speedSlider" min="10" max="1000" value="100" step="10">
                <div class="label-inline">

                    <span id="speedLabel">100 ms</span>

                </div>
            </div>
        </div>

        <canvas id="chart" width="800" height="400"></canvas>
    </div>

    <div class="info">
        <label>Infobox</label><br>

                              <textarea rows="4" cols="115">
Geltungsbereich:
Im Ökosystem gibt es eine Räuberart, die sich maßgeblich von einer Beuteart ernährt.
Also nur extrem artenarmen Ökosystemen.
1. Gesetz: Populationsgrößen schwanken periodisch.
2. Gesetz: Mittelwerte bleiben konstant bei stabilen Bedingungen.
3. Gesetz: Nach Störung erholt sich die Beute schneller als der Räuber.
Variablen Standardwerte: 
Individuen: Beutepopulation: 40 Räuberpopulation: 8
α:Vermehrung der Beute -  die Zerstörungsrate der Beute;  Tod (Verschiedene Ursachen) 0,1
α: > 1: interspezifische Konkurrenz ist stärker als intraspezifische
α: < 1: interspezifische Konkurrenz ist schwächer als intraspezifische

β:  Räuber-Effekt auf Beute - die Zerstörungsrate der Räuber ;Tod (Verschiedene Ursachen) 0,02
 δ: Beute-Effekt auf Räuber: Anzahl der Begegnungen 0,01
Werden die beiden Tierklassen gleichmäßig und proportional zur Populationsgröße dezimiert, 
und ist die Rate der Dezimierung der Beute kleiner als deren Reproduktionsrate, 
so wächst der Mittelwert der Beutepopulation, und der Mittelwert der Räuberpopulation sinkt.)

 γ: Räubersterberate: 0,1
γ1: Fressrate der Räuber pro Beute = Sterberate der Beute pro Räuber 
γ2: Reproduktionsrate der Räuber pro Beute
https://www.biologie-seite.de/Biologie/Lotka-Volterra-Gleichungen

    </textarea>



        <div class="textarea">

            <h4> Aufgaben:  </h4>
            <h4> Geschwindigkeitsregler ganz auf links stellen - Animation starten </h4>
            <h4> 1. Erkläre die Gesetze 1 und 2  nach Lotka-Volterra </h4>
            <h4> Reset für neue Animation </h4>
            <h4>   Verändere die Werte entsprechend der Beispiele. Interpretiere die Kurven. </h4>
            <h4>Beutepopulation: 40 ; Räuber:10            </h4>
            <h4> 2. Verringere beide Populationen um die Hälfte. Vergleiche und ekläre die Unterschiede.    </h4>
            <h4> Stelle die Ausgangswerte wieder her - Reset</h4>
            <h4> Erkläre folgende Veränderungen in den Kurven:</h4>
            <h4> 3. Erhöhe     β: (Räuber-Effekt auf Beute auf 0,04)</h4>
            <h4> 4. Verringere δ: (Beute-Effekt auf Räuber auf 0,005)</h4>
            <h4> 5. Erhöhe     γ: (Räubersterberate auf 0,4)</h4>
        </div>


    </div>



    <script>
        const canvas = document.getElementById("chart");
        const ctx = canvas.getContext("2d");

        const preyInput = document.getElementById("preyInput");
        const predatorInput = document.getElementById("predatorInput");
        const minPreyInput = document.getElementById("minPreyInput");
        const alphaInput = document.getElementById("alphaInput");
        const betaInput = document.getElementById("betaInput");
        const deltaInput = document.getElementById("deltaInput");
        const gammaInput = document.getElementById("gammaInput");
        const speedSlider = document.getElementById("speedSlider");
        const speedLabel = document.getElementById("speedLabel");
        const toggleBtn = document.getElementById("toggleBtn");

        let prey = 40;
        let predator = 9;
        let preyHistory = [];
        let predatorHistory = [];
        let time = 0;
        const dt = 0.5;
        const maxSteps = 1000;
        let interval = null;

        function drawChart() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const maxTime = preyHistory.length;
            const maxPop = Math.max(...preyHistory, ...predatorHistory) * 1.2;

            ctx.strokeStyle = "#34c759";
            drawLine(preyHistory, maxTime, maxPop);
            ctx.strokeStyle = "#ff3b30";
            drawLine(predatorHistory, maxTime, maxPop);

            if (preyHistory.length > 0) {
                const meanPrey = preyHistory.reduce((a, b) => a + b, 0) / preyHistory.length;
                const meanPredator = predatorHistory.reduce((a, b) => a + b, 0) / predatorHistory.length;

                ctx.strokeStyle = "rgba(52, 199, 89, 0.4)";
                drawHorizontalLine(meanPrey, maxTime, maxPop, [5, 5]);

                ctx.strokeStyle = "rgba(255, 59, 48, 0.4)";
                drawHorizontalLine(meanPredator, maxTime, maxPop, [5, 5]);
            }
        }

        function drawLine(data, maxTime, maxPop) {
            ctx.beginPath();
            ctx.setLineDash([]);
            data.forEach((value, i) => {
                const x = (i / maxSteps) * canvas.width;
                const y = canvas.height - (value / maxPop) * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }

        function drawHorizontalLine(value, maxTime, maxPop, dash) {
            const y = canvas.height - (value / maxPop) * canvas.height;
            ctx.beginPath();
            ctx.setLineDash(dash);
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function lotkaVolterraStep() {
            const alpha = parseFloat(alphaInput.value);
            const beta = parseFloat(betaInput.value);
            const delta = parseFloat(deltaInput.value);
            const gamma = parseFloat(gammaInput.value);
            const minPrey = parseFloat(minPreyInput.value);

            const dPrey = (alpha * prey - beta * prey * predator) * dt;
            const dPredator = (delta * prey * predator - gamma * predator) * dt;

            prey = Math.max(prey + dPrey, minPrey);
            predator = Math.max(predator + dPredator, 0.01);
        }

        function simulationTick() {
            lotkaVolterraStep();
            preyHistory.push(prey);
            predatorHistory.push(predator);
            time += dt;
            drawChart();

            if (prey <= 0) {
                stopSimulation();
                alert("Simulation gestoppt: Beutepopulation ist auf 0 gefallen.");
            }

            if (predator <= 0) {
                stopSimulation();
                alert("Simulation gestoppt: Räuberpopulation ist auf 0 gefallen.");
            }

            if (time >= maxSteps) stopSimulation();
        }

        function toggleSimulation() {
            if (interval) {
                stopSimulation();
                toggleBtn.textContent = "Weiter";
            } else {
                const startPrey = parseFloat(preyInput.value);
                const startPredator = parseFloat(predatorInput.value);
                const minPrey = parseFloat(minPreyInput.value);

                if (startPrey <= 0 || startPredator <= 0 || minPrey < 1) {
                    alert("Bitte gültige Startwerte eingeben.");
                    return;
                }

                if (time === 0 || preyHistory.length === 0) {
                    prey = startPrey;
                    predator = startPredator;
                    preyHistory = [prey];
                    predatorHistory = [predator];
                    time = 0;
                }

                const speed = parseInt(speedSlider.value);
                interval = setInterval(simulationTick, speed);
                toggleBtn.textContent = "Stopp";
            }
        }

        function stopSimulation() {
            clearInterval(interval);
            interval = null;
        }

        function resetSimulation() {
            stopSimulation();
            time = 0;
            prey = parseFloat(preyInput.value);
            predator = parseFloat(predatorInput.value);
            preyHistory = [prey];
            predatorHistory = [predator];
            drawChart();
            toggleBtn.textContent = "Start";
        }

        speedSlider.addEventListener("input", () => {
            speedLabel.textContent = `${speedSlider.value} ms`;
            if (interval) {
                stopSimulation();
                toggleSimulation();
            }
        });

        resetSimulation();
    </script>

    <script>
        function openQRCode() {
            const currentUrl = window.location.href;
            const qrWin = window.open("", "_blank", "width=520,height=600,resizable=yes,scrollbars=no");

            qrWin.document.write(`
            <html lang="de">
            <head>
              <meta charset="UTF-8">
              <title>QR-Code</title>
              <style>
                body {
                  font-family: Arial, sans-serif;
                  text-align: center;
                  background: #fff;
                  padding: 30px;
                }
                #qrcode { margin-top: 40px; }
                button {
                  margin-top: 40px;
                  background: #0071e3;
                  color: #fff;
                  border: none;
                  border-radius: 10px;
                  font-size: 16px;
                  padding: 10px 20px;
                  cursor: pointer;
                }
                button:hover { background: #005bb5; }
              </style>
            </head>
            <body>
              <h2>QR-Code zu dieser Seite</h2>
              <div id="qrcode"></div>
              <button onclick="window.close()">Fenster schließen</button>
              <script src="libs/qrcode.min.js"><\/script>
              <script>
                window.addEventListener('load', function() {
                  new QRCode(document.getElementById("qrcode"), {
                    text: "${currentUrl}",
                    width: 220,
                    height: 220,
                    correctLevel: QRCode.CorrectLevel.H
                  });
                });
              <\/script>
            </body>
            </html>
          `);

            qrWin.document.close();
        }
    </script>




</body>
</html>
